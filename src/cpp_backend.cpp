#include "cpp_backend.hpp"
#include <sstream>
#include <algorithm>

namespace bnf_parser_generator {

GeneratedCode CppCodeGenerator::generate(const Grammar& grammar, const GeneratorOptions& options) {
    GeneratedCode result;
    options_ = options;
    
    // Валидация грамматики
    if (grammar.rules.empty()) {
        result.success = false;
        result.error_message = "Grammar has no rules";
        return result;
    }
    
    if (grammar.startSymbol.empty()) {
        result.success = false;
        result.error_message = "Grammar has no start symbol";
        return result;
    }
    
    try {
        // Генерация различных частей парсера
        std::ostringstream code;
        
        code << generateHeader();
        code << generateIncludes();
        code << "\n";
        code << generateASTNodeClasses(grammar);
        code << "\n";
        code << generateParserClass(grammar);
        code << "\n";
        code << generateFooter();
        
        result.parser_code = code.str();
        result.parser_filename = makeIdentifier(options_.parser_name) + ".cpp";
        result.success = true;
        
        result.messages.push_back("Generated C++ parser successfully");
        result.messages.push_back("Total rules: " + std::to_string(grammar.rules.size()));
        result.messages.push_back("Start symbol: " + grammar.startSymbol);
        
        // Генерация main.cpp если требуется исполняемый файл
        if (options_.generate_executable) {
            result.main_code = generateMainCpp(grammar);
            result.main_filename = makeIdentifier(options_.parser_name) + "_main.cpp";
            result.messages.push_back("Generated standalone executable main.cpp");
        }
        
    } catch (const std::exception& e) {
        result.success = false;
        result.error_message = std::string("Generation failed: ") + e.what();
    }
    
    return result;
}

std::string CppCodeGenerator::generateHeader() {
    std::ostringstream ss;
    ss << "// Generated by BNF Parser Generator\n";
    ss << "// Parser: " << options_.parser_name << "\n";
    ss << "// Language: C++17\n";
    ss << "// This is a standalone parser with no external dependencies\n";
    ss << "\n";
    return ss.str();
}

std::string CppCodeGenerator::generateIncludes() {
    std::ostringstream ss;
    ss << "#include <string>\n";
    ss << "#include <vector>\n";
    ss << "#include <memory>\n";
    ss << "#include <stdexcept>\n";
    ss << "#include <sstream>\n";
    ss << "#include <iostream>\n";
    ss << "\n";
    return ss.str();
}

std::string CppCodeGenerator::generateASTNodeClasses(const Grammar& grammar) {
    std::ostringstream ss;
    
    std::string ns = options_.namespace_name.empty() ? "" : options_.namespace_name;
    
    if (!ns.empty()) {
        ss << "namespace " << ns << " {\n\n";
    }
    
    ss << "// AST Node base class\n";
    ss << "class ASTNode {\n";
    ss << "public:\n";
    ss << "    virtual ~ASTNode() = default;\n";
    ss << "    virtual std::string toString() const = 0;\n";
    
    if (options_.track_positions) {
        ss << "    size_t line = 0;\n";
        ss << "    size_t column = 0;\n";
    }
    
    ss << "};\n\n";
    
    // Генерация узлов для каждого правила грамматики
    for (const auto& rule : grammar.rules) {
        std::string class_name = makeIdentifier(rule->leftSide) + "Node";
        ss << "// AST Node for rule: " << rule->leftSide << "\n";
        ss << "class " << class_name << " : public ASTNode {\n";
        ss << "public:\n";
        ss << "    std::vector<std::unique_ptr<ASTNode>> children;\n";
        ss << "    std::string value;\n";
        ss << "\n";
        ss << "    std::string toString() const override {\n";
        ss << "        return \"" << rule->leftSide << "\";\n";
        ss << "    }\n";
        ss << "};\n\n";
    }
    
    if (!ns.empty()) {
        ss << "} // namespace " << ns << "\n\n";
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateParserClass(const Grammar& grammar) {
    std::ostringstream ss;
    
    std::string ns = options_.namespace_name.empty() ? "" : options_.namespace_name;
    
    if (!ns.empty()) {
        ss << "namespace " << ns << " {\n\n";
    }
    
    ss << "// Parser class\n";
    ss << "class " << options_.parser_name << " {\n";
    ss << "private:\n";
    ss << "    std::string input_;\n";
    ss << "    size_t pos_ = 0;\n";
    ss << "    size_t line_ = 1;\n";
    ss << "    size_t column_ = 1;\n";
    ss << "    std::string error_message_;\n";
    ss << "    size_t recursion_depth_ = 0;\n";
    ss << "\n";
    ss << "public:\n";
    ss << "    explicit " << options_.parser_name << "(const std::string& input)\n";
    ss << "        : input_(input) {}\n";
    ss << "\n";
    
    // Главный метод парсинга
    ss << generateMainParseMethod(grammar);
    ss << "\n";
    
    ss << "    const std::string& getError() const { return error_message_; }\n";
    ss << "\n";
    ss << "private:\n";
    
    // Генерация функций для каждого правила
    for (const auto& rule : grammar.rules) {
        ss << generateRuleFunction(*rule);
        ss << "\n";
    }
    
    // Вспомогательные методы
    ss << generateHelperMethods();
    
    ss << "};\n\n";
    
    if (!ns.empty()) {
        ss << "} // namespace " << ns << "\n\n";
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateMainParseMethod(const Grammar& grammar) {
    std::ostringstream ss;
    
    ss << "    // Main parsing method\n";
    ss << "    std::unique_ptr<ASTNode> parse() {\n";
    ss << "        pos_ = 0;\n";
    ss << "        line_ = 1;\n";
    ss << "        column_ = 1;\n";
    ss << "        error_message_.clear();\n";
    ss << "        recursion_depth_ = 0;\n";
    ss << "\n";
    ss << "        auto result = parse_" << makeIdentifier(grammar.startSymbol) << "();\n";
    ss << "\n";
    ss << "        if (!result) {\n";
    ss << "            if (error_message_.empty()) {\n";
    ss << "                error_message_ = \"Parse failed at position \" + std::to_string(pos_);\n";
    ss << "            }\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        // Check if we consumed all input\n";
    ss << "        skipWhitespace();\n";
    ss << "        if (pos_ < input_.size()) {\n";
    ss << "            error_message_ = \"Unexpected input at position \" + std::to_string(pos_);\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        return result;\n";
    ss << "    }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateRuleFunction(const ProductionRule& rule) {
    std::ostringstream ss;
    
    // Сброс счетчика переменных для каждой функции
    variable_counter_ = 0;
    
    std::string func_name = "parse_" + makeIdentifier(rule.leftSide);
    
    ss << "    // Parse rule: " << rule.leftSide << "\n";
    ss << "    std::unique_ptr<ASTNode> " << func_name << "() {\n";
    ss << "        // Recursion depth check\n";
    ss << "        if (++recursion_depth_ > " << options_.max_recursion_depth << ") {\n";
    ss << "            error_message_ = \"Maximum recursion depth exceeded\";\n";
    ss << "            --recursion_depth_;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        size_t saved_pos = pos_;\n";
    ss << "        size_t saved_line = line_;\n";
    ss << "        size_t saved_column = column_;\n";
    ss << "\n";
    
    // Генерация кода для правой части правила
    std::string node_code = visitNode(rule.rightSide.get());
    
    ss << "        auto node = std::make_unique<" << makeIdentifier(rule.leftSide) << "Node>();\n";
    ss << node_code;
    ss << "\n";
    ss << "        --recursion_depth_;\n";
    ss << "        return node;\n";
    ss << "    }\n";
    
    return ss.str();
}

// Обобщённый метод визитации узлов
std::string CppCodeGenerator::visitNode(const ASTNode* node) {
    if (const auto* term = dynamic_cast<const Terminal*>(node)) {
        return visitTerminal(term);
    } else if (const auto* nonterm = dynamic_cast<const NonTerminal*>(node)) {
        return visitNonTerminal(nonterm);
    } else if (const auto* range = dynamic_cast<const CharRange*>(node)) {
        return visitCharRange(range);
    } else if (const auto* alt = dynamic_cast<const Alternative*>(node)) {
        return visitAlternative(alt);
    } else if (const auto* seq = dynamic_cast<const Sequence*>(node)) {
        return visitSequence(seq);
    } else if (const auto* group = dynamic_cast<const Group*>(node)) {
        return visitGroup(group);
    } else if (const auto* opt = dynamic_cast<const Optional*>(node)) {
        return visitOptional(opt);
    } else if (const auto* zero = dynamic_cast<const ZeroOrMore*>(node)) {
        return visitZeroOrMore(zero);
    } else if (const auto* one = dynamic_cast<const OneOrMore*>(node)) {
        return visitOneOrMore(one);
    }
    
    return "        // Unknown node type\n";
}

std::string CppCodeGenerator::visitTerminal(const Terminal* node) {
    std::ostringstream ss;
    ss << "        // Match terminal: \"" << escapeString(node->value) << "\"\n";
    ss << "        if (!matchString(\"" << escapeString(node->value) << "\")) {\n";
    ss << "            pos_ = saved_pos;\n";
    ss << "            line_ = saved_line;\n";
    ss << "            column_ = saved_column;\n";
    ss << "            --recursion_depth_;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::visitNonTerminal(const NonTerminal* node) {
    std::ostringstream ss;
    std::string child_var = "child_" + std::to_string(variable_counter_++);
    ss << "        // Parse non-terminal: " << node->name << "\n";
    ss << "        auto " << child_var << " = parse_" << makeIdentifier(node->name) << "();\n";
    ss << "        if (!" << child_var << ") {\n";
    ss << "            pos_ = saved_pos;\n";
    ss << "            line_ = saved_line;\n";
    ss << "            column_ = saved_column;\n";
    ss << "            --recursion_depth_;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "        node->children.push_back(std::move(" << child_var << "));\n";
    return ss.str();
}

std::string CppCodeGenerator::visitCharRange(const CharRange* node) {
    std::ostringstream ss;
    ss << "        // Match character range: '" << node->start << "' .. '" << node->end << "'\n";
    ss << "        if (pos_ >= input_.size() || input_[pos_] < '" << node->start 
       << "' || input_[pos_] > '" << node->end << "') {\n";
    ss << "            pos_ = saved_pos;\n";
    ss << "            line_ = saved_line;\n";
    ss << "            column_ = saved_column;\n";
    ss << "            --recursion_depth_;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "        advance();\n";
    return ss.str();
}

// Helper function to generate inline parsing code for any node with success flag
std::string CppCodeGenerator::generateInlineNode(const ASTNode* node, const std::string& success_var, const std::string& indent) {
    std::ostringstream ss;
    
    if (const auto* term = dynamic_cast<const Terminal*>(node)) {
        ss << indent << "if (" << success_var << " && !matchString(\"" << escapeString(term->value) << "\")) {\n";
        ss << indent << "    " << success_var << " = false;\n";
        ss << indent << "}\n";
    } else if (const auto* nonterm = dynamic_cast<const NonTerminal*>(node)) {
        std::string child_var = "inline_child_" + std::to_string(variable_counter_++);
        ss << indent << "std::unique_ptr<ASTNode> " << child_var << ";\n";
        ss << indent << "if (" << success_var << ") {\n";
        ss << indent << "    " << child_var << " = parse_" << makeIdentifier(nonterm->name) << "();\n";
        ss << indent << "    if (" << child_var << ") {\n";
        ss << indent << "        node->children.push_back(std::move(" << child_var << "));\n";
        ss << indent << "    } else {\n";
        ss << indent << "        " << success_var << " = false;\n";
        ss << indent << "    }\n";
        ss << indent << "}\n";
    } else if (const auto* seq = dynamic_cast<const Sequence*>(node)) {
        for (const auto& elem : seq->elements) {
            ss << generateInlineNode(elem.get(), success_var, indent);
        }
    } else if (const auto* grp = dynamic_cast<const Group*>(node)) {
        ss << generateInlineNode(grp->content.get(), success_var, indent);
    } else if (const auto* cr = dynamic_cast<const CharRange*>(node)) {
        ss << indent << "if (" << success_var << " && (pos_ >= input_.size() || input_[pos_] < '" 
           << cr->start << "' || input_[pos_] > '" << cr->end << "')) {\n";
        ss << indent << "    " << success_var << " = false;\n";
        ss << indent << "} else if (" << success_var << ") {\n";
        ss << indent << "    advance();\n";
        ss << indent << "}\n";
    } else {
        // For complex nodes (Optional, ZeroOrMore, etc.), fail for now
        // These should not appear directly in alternatives without being wrapped in Sequence
        ss << indent << "// Complex node type in alternative - not supported inline\n";
        ss << indent << success_var << " = false;\n";
    }
    
    return ss.str();
}

std::string CppCodeGenerator::visitAlternative(const Alternative* node) {
    std::ostringstream ss;
    ss << "        // Try alternatives\n";
    ss << "        {\n";
    ss << "            bool alt_matched = false;\n";
    
    for (size_t i = 0; i < node->choices.size(); ++i) {
        ss << "            // Alternative " << (i + 1) << "\n";
        ss << "            if (!alt_matched) {\n";
        ss << "                size_t alt_pos = pos_;\n";
        ss << "                size_t alt_line = line_;\n";
        ss << "                size_t alt_column = column_;\n";
        ss << "                bool alt_success = true;\n";
        
        // Generate inline code for this alternative using helper
        ss << generateInlineNode(node->choices[i].get(), "alt_success", "                ");
        
        ss << "                if (alt_success) {\n";
        ss << "                    alt_matched = true;\n";
        ss << "                } else {\n";
        ss << "                    pos_ = alt_pos;\n";
        ss << "                    line_ = alt_line;\n";
        ss << "                    column_ = alt_column;\n";
        ss << "                }\n";
        ss << "            }\n";
    }
    
    ss << "            if (!alt_matched) {\n";
    ss << "                pos_ = saved_pos;\n";
    ss << "                line_ = saved_line;\n";
    ss << "                column_ = saved_column;\n";
    ss << "                --recursion_depth_;\n";
    ss << "                return nullptr;\n";
    ss << "            }\n";
    ss << "        }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::visitSequence(const Sequence* node) {
    std::ostringstream ss;
    ss << "        // Parse sequence\n";
    for (const auto& element : node->elements) {
        ss << visitNode(element.get());
    }
    return ss.str();
}

std::string CppCodeGenerator::visitGroup(const Group* node) {
    return visitNode(node->content.get());
}

std::string CppCodeGenerator::visitOptional(const Optional* node) {
    std::ostringstream ss;
    ss << "        // Optional\n";
    ss << "        {\n";
    ss << "            size_t opt_pos = pos_;\n";
    ss << "            size_t opt_line = line_;\n";
    ss << "            size_t opt_column = column_;\n";
    
    if (const auto* nonterm = dynamic_cast<const NonTerminal*>(node->content.get())) {
        std::string child_var = "opt_child";
        ss << "            auto " << child_var << " = parse_" << makeIdentifier(nonterm->name) << "();\n";
        ss << "            if (" << child_var << ") {\n";
        ss << "                node->children.push_back(std::move(" << child_var << "));\n";
        ss << "            } else {\n";
        ss << "                pos_ = opt_pos;\n";
        ss << "                line_ = opt_line;\n";
        ss << "                column_ = opt_column;\n";
        ss << "            }\n";
    } else if (const auto* term = dynamic_cast<const Terminal*>(node->content.get())) {
        ss << "            if (!matchString(\"" << escapeString(term->value) << "\")) {\n";
        ss << "                pos_ = opt_pos;\n";
        ss << "                line_ = opt_line;\n";
        ss << "                column_ = opt_column;\n";
        ss << "            }\n";
    }
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::visitZeroOrMore(const ZeroOrMore* node) {
    std::ostringstream ss;
    ss << "        // Zero or more repetitions\n";
    ss << "        while (true) {\n";
    ss << "            size_t rep_pos = pos_;\n";
    ss << "            size_t rep_line = line_;\n";
    ss << "            size_t rep_column = column_;\n";
    
    if (const auto* nonterm = dynamic_cast<const NonTerminal*>(node->content.get())) {
        std::string child_var = "rep_child";
        ss << "            auto " << child_var << " = parse_" << makeIdentifier(nonterm->name) << "();\n";
        ss << "            if (!" << child_var << ") {\n";
        ss << "                pos_ = rep_pos;\n";
        ss << "                line_ = rep_line;\n";
        ss << "                column_ = rep_column;\n";
        ss << "                break;\n";
        ss << "            }\n";
        ss << "            node->children.push_back(std::move(" << child_var << "));\n";
    } else if (const auto* term = dynamic_cast<const Terminal*>(node->content.get())) {
        ss << "            if (!matchString(\"" << escapeString(term->value) << "\")) {\n";
        ss << "                pos_ = rep_pos;\n";
        ss << "                line_ = rep_line;\n";
        ss << "                column_ = rep_column;\n";
        ss << "                break;\n";
        ss << "            }\n";
    } else if (const auto* grp = dynamic_cast<const Group*>(node->content.get())) {
        // Handle group (unwrap and process content)
        if (const auto* alt = dynamic_cast<const Alternative*>(grp->content.get())) {
            // Group contains Alternative
            ss << "            bool rep_matched = false;\n";
            for (size_t i = 0; i < alt->choices.size(); ++i) {
                ss << "            if (!rep_matched) {\n";
                ss << "                size_t alt_pos = pos_;\n";
                ss << "                size_t alt_line = line_;\n";
                ss << "                size_t alt_column = column_;\n";
                if (const auto* term = dynamic_cast<const Terminal*>(alt->choices[i].get())) {
                    ss << "                if (matchString(\"" << escapeString(term->value) << "\")) {\n";
                    ss << "                    rep_matched = true;\n";
                    ss << "                } else {\n";
                    ss << "                    pos_ = alt_pos;\n";
                    ss << "                    line_ = alt_line;\n";
                    ss << "                    column_ = alt_column;\n";
                    ss << "                }\n";
                } else {
                    ss << "                // TODO: Complex choice in repetition\n";
                }
                ss << "            }\n";
            }
            ss << "            if (!rep_matched) {\n";
            ss << "                pos_ = rep_pos;\n";
            ss << "                line_ = rep_line;\n";
            ss << "                column_ = rep_column;\n";
            ss << "                break;\n";
            ss << "            }\n";
        } else {
            ss << "            // TODO: Group with non-alternative content\n";
            ss << "            break;\n";
        }
    } else if (const auto* alt = dynamic_cast<const Alternative*>(node->content.get())) {
        // Handle alternative inside repetition (direct, no group)
        ss << "            bool rep_matched = false;\n";
        for (size_t i = 0; i < alt->choices.size(); ++i) {
            ss << "            if (!rep_matched) {\n";
            ss << "                size_t alt_pos = pos_;\n";
            ss << "                size_t alt_line = line_;\n";
            ss << "                size_t alt_column = column_;\n";
            if (const auto* term = dynamic_cast<const Terminal*>(alt->choices[i].get())) {
                ss << "                if (matchString(\"" << escapeString(term->value) << "\")) {\n";
                ss << "                    rep_matched = true;\n";
                ss << "                } else {\n";
                ss << "                    pos_ = alt_pos;\n";
                ss << "                    line_ = alt_line;\n";
                ss << "                    column_ = alt_column;\n";
                ss << "                }\n";
            } else {
                ss << "                // TODO: Complex choice in repetition\n";
            }
            ss << "            }\n";
        }
        ss << "            if (!rep_matched) {\n";
            ss << "                pos_ = rep_pos;\n";
            ss << "                line_ = rep_line;\n";
            ss << "                column_ = rep_column;\n";
            ss << "                break;\n";
            ss << "            }\n";
    } else {
        // Generic fallback - shouldn't happen in simple cases
        ss << "            // TODO: Generic repetition content\n";
        ss << "            break; // Prevent infinite loop\n";
    }
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::visitOneOrMore(const OneOrMore* node) {
    std::ostringstream ss;
    ss << "        // One or more repetitions\n";
    ss << "        {\n";
    ss << "            bool matched_once = false;\n";
    ss << "            while (true) {\n";
    ss << "                size_t rep_pos = pos_;\n";
    ss << "                size_t rep_line = line_;\n";
    ss << "                size_t rep_column = column_;\n";
    
    if (const auto* nonterm = dynamic_cast<const NonTerminal*>(node->content.get())) {
        std::string child_var = "rep_child";
        ss << "                auto " << child_var << " = parse_" << makeIdentifier(nonterm->name) << "();\n";
        ss << "                if (!" << child_var << ") {\n";
        ss << "                    pos_ = rep_pos;\n";
        ss << "                    line_ = rep_line;\n";
        ss << "                    column_ = rep_column;\n";
        ss << "                    break;\n";
        ss << "                }\n";
        ss << "                node->children.push_back(std::move(" << child_var << "));\n";
        ss << "                matched_once = true;\n";
    }
    ss << "            }\n";
    ss << "            if (!matched_once) {\n";
    ss << "                pos_ = saved_pos;\n";
    ss << "                line_ = saved_line;\n";
    ss << "                column_ = saved_column;\n";
    ss << "                --recursion_depth_;\n";
    ss << "                return nullptr;\n";
    ss << "            }\n";
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::generateHelperMethods() {
    std::ostringstream ss;
    
    ss << "    // Helper methods\n";
    ss << "    void skipWhitespace() {\n";
    ss << "        while (pos_ < input_.size() && std::isspace(input_[pos_])) {\n";
    ss << "            if (input_[pos_] == '\\n') {\n";
    ss << "                ++line_;\n";
    ss << "                column_ = 1;\n";
    ss << "            } else {\n";
    ss << "                ++column_;\n";
    ss << "            }\n";
    ss << "            ++pos_;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "\n";
    ss << "    void advance() {\n";
    ss << "        if (pos_ < input_.size()) {\n";
    ss << "            if (input_[pos_] == '\\n') {\n";
    ss << "                ++line_;\n";
    ss << "                column_ = 1;\n";
    ss << "            } else {\n";
    ss << "                ++column_;\n";
    ss << "            }\n";
    ss << "            ++pos_;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "\n";
    ss << "    bool matchString(const std::string& str) {\n";
    ss << "        skipWhitespace();\n";
    ss << "        if (pos_ + str.size() > input_.size()) {\n";
    ss << "            return false;\n";
    ss << "        }\n";
    ss << "        if (input_.substr(pos_, str.size()) == str) {\n";
    ss << "            for (size_t i = 0; i < str.size(); ++i) {\n";
    ss << "                advance();\n";
    ss << "            }\n";
    ss << "            return true;\n";
    ss << "        }\n";
    ss << "        return false;\n";
    ss << "    }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateFooter() {
    return "// End of generated parser\n";
}

std::string CppCodeGenerator::getIndent(size_t level) const {
    return std::string(level * 4, ' ');
}

std::string CppCodeGenerator::generateComment(const std::string& comment) const {
    return "// " + comment + "\n";
}

std::string CppCodeGenerator::generateMainCpp(const Grammar& /* grammar */) {
    std::ostringstream ss;
    
    ss << "// Generated main.cpp for " << options_.parser_name << "\n";
    ss << "// This file provides a command-line interface for the parser\n\n";
    
    ss << "#include <iostream>\n";
    ss << "#include <fstream>\n";
    ss << "#include <sstream>\n";
    ss << "#include <string>\n";
    ss << "#include <cstring>\n\n";
    
    ss << "// Include the generated parser\n";
    ss << "#include \"" << makeIdentifier(options_.parser_name) << ".cpp\"\n\n";
    
    if (!options_.namespace_name.empty()) {
        ss << "using namespace " << options_.namespace_name << ";\n\n";
    }
    
    ss << "struct CommandLineOptions {\n";
    ss << "    std::string input_file;\n";
    ss << "    bool show_ast = false;\n";
    ss << "    bool verbose = false;\n";
    ss << "    bool help = false;\n";
    ss << "};\n\n";
    
    ss << "void printHelp(const char* program_name) {\n";
    ss << "    std::cout << \"" << options_.parser_name << " - Generated parser\\n\\n\";\n";
    ss << "    std::cout << \"Usage: \" << program_name << \" [options] <input_file>\\n\\n\";\n";
    ss << "    std::cout << \"Options:\\n\";\n";
    ss << "    std::cout << \"  -a, --ast       Show parsed AST\\n\";\n";
    ss << "    std::cout << \"  -v, --verbose   Verbose output\\n\";\n";
    ss << "    std::cout << \"  -h, --help      Show this help\\n\";\n";
    ss << "}\n\n";
    
    ss << "CommandLineOptions parseArgs(int argc, char* argv[]) {\n";
    ss << "    CommandLineOptions opts;\n";
    ss << "    \n";
    ss << "    for (int i = 1; i < argc; ++i) {\n";
    ss << "        std::string arg = argv[i];\n";
    ss << "        if (arg == \"-h\" || arg == \"--help\") {\n";
    ss << "            opts.help = true;\n";
    ss << "        } else if (arg == \"-a\" || arg == \"--ast\") {\n";
    ss << "            opts.show_ast = true;\n";
    ss << "        } else if (arg == \"-v\" || arg == \"--verbose\") {\n";
    ss << "            opts.verbose = true;\n";
    ss << "        } else if (arg[0] != '-') {\n";
    ss << "            opts.input_file = arg;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "    \n";
    ss << "    return opts;\n";
    ss << "}\n\n";
    
    ss << "std::string readFile(const std::string& filename) {\n";
    ss << "    std::ifstream file(filename);\n";
    ss << "    if (!file) {\n";
    ss << "        throw std::runtime_error(\"Cannot open file: \" + filename);\n";
    ss << "    }\n";
    ss << "    std::stringstream buffer;\n";
    ss << "    buffer << file.rdbuf();\n";
    ss << "    return buffer.str();\n";
    ss << "}\n\n";
    
    ss << "int main(int argc, char* argv[]) {\n";
    ss << "    try {\n";
    ss << "        auto opts = parseArgs(argc, argv);\n";
    ss << "        \n";
    ss << "        if (opts.help || opts.input_file.empty()) {\n";
    ss << "            printHelp(argv[0]);\n";
    ss << "            return opts.help ? 0 : 1;\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        if (opts.verbose) {\n";
    ss << "            std::cout << \"Parsing file: \" << opts.input_file << \"\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        std::string input = readFile(opts.input_file);\n";
    ss << "        \n";
    ss << "        if (opts.verbose) {\n";
    ss << "            std::cout << \"Input size: \" << input.size() << \" bytes\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        " << options_.parser_name << " parser(input);\n";
    ss << "        auto result = parser.parse();\n";
    ss << "        \n";
    ss << "        if (!result) {\n";
    ss << "            std::cerr << \"Parse error: \" << parser.getError() << \"\\n\";\n";
    ss << "            return 1;\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        if (opts.verbose) {\n";
    ss << "            std::cout << \"✓ Parse successful\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        if (opts.show_ast) {\n";
    ss << "            std::cout << \"AST:\\n\" << result->toString() << \"\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        return 0;\n";
    ss << "        \n";
    ss << "    } catch (const std::exception& e) {\n";
    ss << "        std::cerr << \"Error: \" << e.what() << \"\\n\";\n";
    ss << "        return 1;\n";
    ss << "    }\n";
    ss << "}\n";
    
    return ss.str();
}

} // namespace bnf_parser_generator


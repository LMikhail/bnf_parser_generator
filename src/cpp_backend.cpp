#include "cpp_backend.hpp"
#include <sstream>
#include <algorithm>

namespace bnf_parser_generator {

GeneratedCode CppCodeGenerator::generate(const Grammar& grammar, const GeneratorOptions& options) {
    GeneratedCode result;
    options_ = options;
    
    // Валидация грамматики
    if (grammar.rules.empty()) {
        result.success = false;
        result.error_message = "Grammar has no rules";
        return result;
    }
    
    if (grammar.startSymbol.empty()) {
        result.success = false;
        result.error_message = "Grammar has no start symbol";
        return result;
    }
    
    try {
        // Генерация различных частей парсера
        std::ostringstream code;
        
        code << generateHeader();
        code << generateIncludes();
        code << "\n";
        code << generateASTNodeClasses(grammar);
        code << "\n";
        code << generateParserClass(grammar);
        code << "\n";
        code << generateFooter();
        
        result.parser_code = code.str();
        result.parser_filename = makeIdentifier(options_.parser_name) + ".cpp";
        result.success = true;
        
        result.messages.push_back("Generated C++ parser successfully");
        result.messages.push_back("Total rules: " + std::to_string(grammar.rules.size()));
        result.messages.push_back("Start symbol: " + grammar.startSymbol);
        
    } catch (const std::exception& e) {
        result.success = false;
        result.error_message = std::string("Generation failed: ") + e.what();
    }
    
    return result;
}

std::string CppCodeGenerator::generateHeader() {
    std::ostringstream ss;
    ss << "// Generated by BNF Parser Generator\n";
    ss << "// Parser: " << options_.parser_name << "\n";
    ss << "// Language: C++17\n";
    ss << "// This is a standalone parser with no external dependencies\n";
    ss << "\n";
    return ss.str();
}

std::string CppCodeGenerator::generateIncludes() {
    std::ostringstream ss;
    ss << "#include <string>\n";
    ss << "#include <vector>\n";
    ss << "#include <memory>\n";
    ss << "#include <stdexcept>\n";
    ss << "#include <sstream>\n";
    ss << "#include <iostream>\n";
    ss << "\n";
    return ss.str();
}

std::string CppCodeGenerator::generateASTNodeClasses(const Grammar& grammar) {
    std::ostringstream ss;
    
    std::string ns = options_.namespace_name.empty() ? "" : options_.namespace_name;
    
    if (!ns.empty()) {
        ss << "namespace " << ns << " {\n\n";
    }
    
    ss << "// AST Node base class\n";
    ss << "class ASTNode {\n";
    ss << "public:\n";
    ss << "    virtual ~ASTNode() = default;\n";
    ss << "    virtual std::string toString() const = 0;\n";
    
    if (options_.track_positions) {
        ss << "    size_t line = 0;\n";
        ss << "    size_t column = 0;\n";
    }
    
    ss << "};\n\n";
    
    // Генерация узлов для каждого правила грамматики
    for (const auto& rule : grammar.rules) {
        std::string class_name = makeIdentifier(rule->leftSide) + "Node";
        ss << "// AST Node for rule: " << rule->leftSide << "\n";
        ss << "class " << class_name << " : public ASTNode {\n";
        ss << "public:\n";
        ss << "    std::vector<std::unique_ptr<ASTNode>> children;\n";
        ss << "    std::string value;\n";
        ss << "\n";
        ss << "    std::string toString() const override {\n";
        ss << "        return \"" << rule->leftSide << "\";\n";
        ss << "    }\n";
        ss << "};\n\n";
    }
    
    if (!ns.empty()) {
        ss << "} // namespace " << ns << "\n\n";
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateParserClass(const Grammar& grammar) {
    std::ostringstream ss;
    
    std::string ns = options_.namespace_name.empty() ? "" : options_.namespace_name;
    
    if (!ns.empty()) {
        ss << "namespace " << ns << " {\n\n";
    }
    
    ss << "// Parser class\n";
    ss << "class " << options_.parser_name << " {\n";
    ss << "private:\n";
    ss << "    std::string input_;\n";
    ss << "    size_t pos_ = 0;\n";
    ss << "    size_t line_ = 1;\n";
    ss << "    size_t column_ = 1;\n";
    ss << "    std::string error_message_;\n";
    ss << "    size_t recursion_depth_ = 0;\n";
    ss << "\n";
    ss << "public:\n";
    ss << "    explicit " << options_.parser_name << "(const std::string& input)\n";
    ss << "        : input_(input) {}\n";
    ss << "\n";
    
    // Главный метод парсинга
    ss << generateMainParseMethod(grammar);
    ss << "\n";
    
    ss << "    const std::string& getError() const { return error_message_; }\n";
    ss << "\n";
    ss << "private:\n";
    
    // Генерация функций для каждого правила
    for (const auto& rule : grammar.rules) {
        ss << generateRuleFunction(*rule);
        ss << "\n";
    }
    
    // Вспомогательные методы
    ss << generateHelperMethods();
    
    ss << "};\n\n";
    
    if (!ns.empty()) {
        ss << "} // namespace " << ns << "\n\n";
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateMainParseMethod(const Grammar& grammar) {
    std::ostringstream ss;
    
    ss << "    // Main parsing method\n";
    ss << "    std::unique_ptr<ASTNode> parse() {\n";
    ss << "        pos_ = 0;\n";
    ss << "        line_ = 1;\n";
    ss << "        column_ = 1;\n";
    ss << "        error_message_.clear();\n";
    ss << "        recursion_depth_ = 0;\n";
    ss << "\n";
    ss << "        auto result = parse_" << makeIdentifier(grammar.startSymbol) << "();\n";
    ss << "\n";
    ss << "        if (!result) {\n";
    ss << "            if (error_message_.empty()) {\n";
    ss << "                error_message_ = \"Parse failed at position \" + std::to_string(pos_);\n";
    ss << "            }\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        // Check if we consumed all input\n";
    ss << "        skipWhitespace();\n";
    ss << "        if (pos_ < input_.size()) {\n";
    ss << "            error_message_ = \"Unexpected input at position \" + std::to_string(pos_);\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        return result;\n";
    ss << "    }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateRuleFunction(const ProductionRule& rule) {
    std::ostringstream ss;
    
    std::string func_name = "parse_" + makeIdentifier(rule.leftSide);
    
    ss << "    // Parse rule: " << rule.leftSide << "\n";
    ss << "    std::unique_ptr<ASTNode> " << func_name << "() {\n";
    ss << "        // Recursion depth check\n";
    ss << "        if (++recursion_depth_ > " << options_.max_recursion_depth << ") {\n";
    ss << "            error_message_ = \"Maximum recursion depth exceeded\";\n";
    ss << "            --recursion_depth_;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        size_t saved_pos = pos_;\n";
    ss << "        size_t saved_line = line_;\n";
    ss << "        size_t saved_column = column_;\n";
    ss << "\n";
    
    // Генерация кода для правой части правила
    std::string node_code = visitNode(rule.rightSide.get());
    
    ss << "        auto node = std::make_unique<" << makeIdentifier(rule.leftSide) << "Node>();\n";
    ss << node_code;
    ss << "\n";
    ss << "        --recursion_depth_;\n";
    ss << "        return node;\n";
    ss << "    }\n";
    
    return ss.str();
}

// Обобщённый метод визитации узлов
std::string CppCodeGenerator::visitNode(const ASTNode* node) {
    if (const auto* term = dynamic_cast<const Terminal*>(node)) {
        return visitTerminal(term);
    } else if (const auto* nonterm = dynamic_cast<const NonTerminal*>(node)) {
        return visitNonTerminal(nonterm);
    } else if (const auto* range = dynamic_cast<const CharRange*>(node)) {
        return visitCharRange(range);
    } else if (const auto* alt = dynamic_cast<const Alternative*>(node)) {
        return visitAlternative(alt);
    } else if (const auto* seq = dynamic_cast<const Sequence*>(node)) {
        return visitSequence(seq);
    } else if (const auto* group = dynamic_cast<const Group*>(node)) {
        return visitGroup(group);
    } else if (const auto* opt = dynamic_cast<const Optional*>(node)) {
        return visitOptional(opt);
    } else if (const auto* zero = dynamic_cast<const ZeroOrMore*>(node)) {
        return visitZeroOrMore(zero);
    } else if (const auto* one = dynamic_cast<const OneOrMore*>(node)) {
        return visitOneOrMore(one);
    }
    
    return "        // Unknown node type\n";
}

std::string CppCodeGenerator::visitTerminal(const Terminal* node) {
    std::ostringstream ss;
    ss << "        // Match terminal: \"" << escapeString(node->value) << "\"\n";
    ss << "        if (!matchString(\"" << escapeString(node->value) << "\")) {\n";
    ss << "            pos_ = saved_pos;\n";
    ss << "            line_ = saved_line;\n";
    ss << "            column_ = saved_column;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::visitNonTerminal(const NonTerminal* node) {
    std::ostringstream ss;
    ss << "        // Parse non-terminal: " << node->name << "\n";
    ss << "        auto child = parse_" << makeIdentifier(node->name) << "();\n";
    ss << "        if (!child) {\n";
    ss << "            pos_ = saved_pos;\n";
    ss << "            line_ = saved_line;\n";
    ss << "            column_ = saved_column;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "        node->children.push_back(std::move(child));\n";
    return ss.str();
}

std::string CppCodeGenerator::visitCharRange(const CharRange* node) {
    std::ostringstream ss;
    ss << "        // Match character range: '" << node->start << "' .. '" << node->end << "'\n";
    ss << "        if (pos_ >= input_.size() || input_[pos_] < '" << node->start 
       << "' || input_[pos_] > '" << node->end << "') {\n";
    ss << "            pos_ = saved_pos;\n";
    ss << "            line_ = saved_line;\n";
    ss << "            column_ = saved_column;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "        advance();\n";
    return ss.str();
}

std::string CppCodeGenerator::visitAlternative(const Alternative* node) {
    std::ostringstream ss;
    ss << "        // Try alternatives\n";
    ss << "        {\n";
    
    for (size_t i = 0; i < node->choices.size(); ++i) {
        ss << "            // Alternative " << (i + 1) << "\n";
        ss << "            {\n";
        ss << "                size_t alt_pos = pos_;\n";
        ss << "                size_t alt_line = line_;\n";
        ss << "                size_t alt_column = column_;\n";
        ss << visitNode(node->choices[i].get());
        ss << "                goto alternative_success;\n";
        ss << "                pos_ = alt_pos;\n";
        ss << "                line_ = alt_line;\n";
        ss << "                column_ = alt_column;\n";
        ss << "            }\n";
    }
    
    ss << "            // No alternative matched\n";
    ss << "            pos_ = saved_pos;\n";
    ss << "            line_ = saved_line;\n";
    ss << "            column_ = saved_column;\n";
    ss << "            return nullptr;\n";
    ss << "            alternative_success:;\n";
    ss << "        }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::visitSequence(const Sequence* node) {
    std::ostringstream ss;
    ss << "        // Parse sequence\n";
    for (const auto& element : node->elements) {
        ss << visitNode(element.get());
    }
    return ss.str();
}

std::string CppCodeGenerator::visitGroup(const Group* node) {
    return visitNode(node->content.get());
}

std::string CppCodeGenerator::visitOptional(const Optional* node) {
    std::ostringstream ss;
    ss << "        // Optional\n";
    ss << "        {\n";
    ss << "            size_t opt_pos = pos_;\n";
    ss << "            size_t opt_line = line_;\n";
    ss << "            size_t opt_column = column_;\n";
    ss << visitNode(node->content.get());
    ss << "            // Continue even if optional part fails\n";
    ss << "            if (false) {\n";
    ss << "                pos_ = opt_pos;\n";
    ss << "                line_ = opt_line;\n";
    ss << "                column_ = opt_column;\n";
    ss << "            }\n";
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::visitZeroOrMore(const ZeroOrMore* node) {
    std::ostringstream ss;
    ss << "        // Zero or more repetitions\n";
    ss << "        while (true) {\n";
    ss << "            size_t rep_pos = pos_;\n";
    ss << "            size_t rep_line = line_;\n";
    ss << "            size_t rep_column = column_;\n";
    ss << visitNode(node->content.get());
    ss << "            if (false) {\n";
    ss << "                pos_ = rep_pos;\n";
    ss << "                line_ = rep_line;\n";
    ss << "                column_ = rep_column;\n";
    ss << "                break;\n";
    ss << "            }\n";
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::visitOneOrMore(const OneOrMore* node) {
    std::ostringstream ss;
    ss << "        // One or more repetitions\n";
    ss << "        {\n";
    ss << "            bool matched_once = false;\n";
    ss << "            while (true) {\n";
    ss << "                size_t rep_pos = pos_;\n";
    ss << "                size_t rep_line = line_;\n";
    ss << "                size_t rep_column = column_;\n";
    ss << visitNode(node->content.get());
    ss << "                matched_once = true;\n";
    ss << "                if (false) {\n";
    ss << "                    pos_ = rep_pos;\n";
    ss << "                    line_ = rep_line;\n";
    ss << "                    column_ = rep_column;\n";
    ss << "                    break;\n";
    ss << "                }\n";
    ss << "            }\n";
    ss << "            if (!matched_once) {\n";
    ss << "                pos_ = saved_pos;\n";
    ss << "                line_ = saved_line;\n";
    ss << "                column_ = saved_column;\n";
    ss << "                return nullptr;\n";
    ss << "            }\n";
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::generateHelperMethods() {
    std::ostringstream ss;
    
    ss << "    // Helper methods\n";
    ss << "    void skipWhitespace() {\n";
    ss << "        while (pos_ < input_.size() && std::isspace(input_[pos_])) {\n";
    ss << "            if (input_[pos_] == '\\n') {\n";
    ss << "                ++line_;\n";
    ss << "                column_ = 1;\n";
    ss << "            } else {\n";
    ss << "                ++column_;\n";
    ss << "            }\n";
    ss << "            ++pos_;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "\n";
    ss << "    void advance() {\n";
    ss << "        if (pos_ < input_.size()) {\n";
    ss << "            if (input_[pos_] == '\\n') {\n";
    ss << "                ++line_;\n";
    ss << "                column_ = 1;\n";
    ss << "            } else {\n";
    ss << "                ++column_;\n";
    ss << "            }\n";
    ss << "            ++pos_;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "\n";
    ss << "    bool matchString(const std::string& str) {\n";
    ss << "        skipWhitespace();\n";
    ss << "        if (pos_ + str.size() > input_.size()) {\n";
    ss << "            return false;\n";
    ss << "        }\n";
    ss << "        if (input_.substr(pos_, str.size()) == str) {\n";
    ss << "            for (size_t i = 0; i < str.size(); ++i) {\n";
    ss << "                advance();\n";
    ss << "            }\n";
    ss << "            return true;\n";
    ss << "        }\n";
    ss << "        return false;\n";
    ss << "    }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateFooter() {
    return "// End of generated parser\n";
}

std::string CppCodeGenerator::getIndent(size_t level) const {
    return std::string(level * 4, ' ');
}

std::string CppCodeGenerator::generateComment(const std::string& comment) const {
    return "// " + comment + "\n";
}

} // namespace bnf_parser_generator


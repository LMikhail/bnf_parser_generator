#include "cpp_backend.hpp"
#include <sstream>
#include <algorithm>

namespace bnf_parser_generator {

GeneratedCode CppCodeGenerator::generate(const Grammar& grammar, const GeneratorOptions& options) {
    GeneratedCode result;
    options_ = options;
    
    // Валидация грамматики
    if (grammar.rules.empty()) {
        result.success = false;
        result.error_message = "Grammar has no rules";
        return result;
    }
    
    if (grammar.startSymbol.empty()) {
        result.success = false;
        result.error_message = "Grammar has no start symbol";
        return result;
    }
    
    try {
        // Генерация различных частей парсера
        std::ostringstream code;
        
        code << generateHeader();
        code << generateIncludes();
        code << "\n";
        code << generateASTNodeClasses(grammar);
        code << "\n";
        code << generateParserClass(grammar);
        code << "\n";
        code << generateFooter();
        
        result.parser_code = code.str();
        // Имя файла в snake_case: JsonParser -> json_parser.cpp
        result.parser_filename = camelToSnake(options_.parser_name) + ".cpp";
        result.success = true;
        
        result.messages.push_back("Generated C++ parser successfully");
        result.messages.push_back("Total rules: " + std::to_string(grammar.rules.size()));
        result.messages.push_back("Start symbol: " + grammar.startSymbol);
        
        // Генерация main.cpp если требуется исполняемый файл
        if (options_.generate_executable) {
            result.main_code = generateMainCpp(grammar);
            // Имя main файла в snake_case: JsonParser -> json_parser_main.cpp
            result.main_filename = camelToSnake(options_.parser_name) + "_main.cpp";
            result.messages.push_back("Generated standalone executable main.cpp");
        }
        
    } catch (const std::exception& e) {
        result.success = false;
        result.error_message = std::string("Generation failed: ") + e.what();
    }
    
    return result;
}

std::string CppCodeGenerator::generateHeader() {
    std::ostringstream ss;
    ss << "// Generated by BNF Parser Generator\n";
    ss << "// Parser: " << options_.parser_name << "\n";
    ss << "// Language: C++20\n";
    ss << "// This is a standalone parser with no external dependencies\n";
    ss << "\n";
    return ss.str();
}

std::string CppCodeGenerator::generateIncludes() {
    std::ostringstream ss;
    ss << "#include <string>\n";
    ss << "#include <vector>\n";
    ss << "#include <memory>\n";
    ss << "#include <stdexcept>\n";
    ss << "#include <sstream>\n";
    ss << "#include <iostream>\n";
    ss << "\n";
    return ss.str();
}

std::string CppCodeGenerator::generateASTNodeClasses(const Grammar& grammar) {
    std::ostringstream ss;
    
    std::string ns = options_.namespace_name.empty() ? "" : options_.namespace_name;
    
    if (!ns.empty()) {
        ss << "namespace " << ns << " {\n\n";
    }
    
    ss << "// AST Node base class\n";
    ss << "class ASTNode {\n";
    ss << "public:\n";
    ss << "    virtual ~ASTNode() = default;\n";
    ss << "    virtual std::string toString() const = 0;\n";
    
    if (options_.track_positions) {
        ss << "    size_t line = 0;\n";
        ss << "    size_t column = 0;\n";
    }
    
    ss << "};\n\n";
    
    // Генерация узлов для каждого правила грамматики
    for (const auto& rule : grammar.rules) {
        std::string class_name = makeIdentifier(rule->leftSide) + "Node";
        ss << "// AST Node for rule: " << rule->leftSide << "\n";
        ss << "class " << class_name << " : public ASTNode {\n";
        ss << "public:\n";
        ss << "    std::vector<std::unique_ptr<ASTNode>> children;\n";
        ss << "    std::string value;\n";
        ss << "\n";
        ss << "    std::string toString() const override {\n";
        ss << "        return \"" << rule->leftSide << "\";\n";
        ss << "    }\n";
        ss << "};\n\n";
    }
    
    if (!ns.empty()) {
        ss << "} // namespace " << ns << "\n\n";
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateParserClass(const Grammar& grammar) {
    std::ostringstream ss;
    
    std::string ns = options_.namespace_name.empty() ? "" : options_.namespace_name;
    
    if (!ns.empty()) {
        ss << "namespace " << ns << " {\n\n";
    }
    
    ss << "// Parser class\n";
    ss << "class " << options_.parser_name << " {\n";
    ss << "private:\n";
    ss << "    std::string input_;\n";
    ss << "    size_t pos_ = 0;\n";
    ss << "    size_t line_ = 1;\n";
    ss << "    size_t column_ = 1;\n";
    ss << "    std::string error_message_;\n";
    ss << "    size_t recursion_depth_ = 0;\n";
    ss << "\n";
    ss << "public:\n";
    ss << "    explicit " << options_.parser_name << "(const std::string& input)\n";
    ss << "        : input_(input) {}\n";
    ss << "\n";
    
    // Главный метод парсинга
    ss << generateMainParseMethod(grammar);
    ss << "\n";
    
    ss << "    const std::string& getError() const { return error_message_; }\n";
    ss << "\n";
    ss << "private:\n";
    
    // Генерация функций для каждого правила
    for (const auto& rule : grammar.rules) {
        ss << generateRuleFunction(*rule);
        ss << "\n";
    }
    
    // Вспомогательные методы
    ss << generateHelperMethods();
    
    ss << "};\n\n";
    
    if (!ns.empty()) {
        ss << "} // namespace " << ns << "\n\n";
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateMainParseMethod(const Grammar& grammar) {
    std::ostringstream ss;
    
    ss << "    // Main parsing method\n";
    ss << "    std::unique_ptr<ASTNode> parse() {\n";
    ss << "        pos_ = 0;\n";
    ss << "        line_ = 1;\n";
    ss << "        column_ = 1;\n";
    ss << "        error_message_.clear();\n";
    ss << "        recursion_depth_ = 0;\n";
    ss << "\n";
    ss << "        auto result = parse_" << makeIdentifier(grammar.startSymbol) << "();\n";
    ss << "\n";
    ss << "        if (!result) {\n";
    ss << "            if (error_message_.empty()) {\n";
    ss << "                error_message_ = \"Parse failed at position \" + std::to_string(pos_);\n";
    ss << "            }\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        // Check if we consumed all input\n";
    ss << "        skipWhitespace();\n";
    ss << "        if (pos_ < input_.size()) {\n";
    ss << "            error_message_ = \"Unexpected input at position \" + std::to_string(pos_);\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        return result;\n";
    ss << "    }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateRuleFunction(const ProductionRule& rule) {
    // Если правило имеет параметры, используем специальную генерацию
    if (rule.hasParameters()) {
        return generateParameterizedFunction(rule);
    }
    
    std::ostringstream ss;
    
    // Сброс счетчика переменных для каждой функции
    variable_counter_ = 0;
    
    std::string func_name = "parse_" + makeIdentifier(rule.leftSide);
    
    ss << "    // Parse rule: " << rule.leftSide << "\n";
    ss << "    std::unique_ptr<ASTNode> " << func_name << "() {\n";
    ss << "        // Recursion depth check\n";
    ss << "        if (++recursion_depth_ > " << options_.max_recursion_depth << ") {\n";
    ss << "            error_message_ = \"Maximum recursion depth exceeded\";\n";
    ss << "            --recursion_depth_;\n";
    ss << "            return nullptr;\n";
    ss << "        }\n";
    ss << "\n";
    ss << "        size_t saved_pos = pos_;\n";
    ss << "        size_t saved_line = line_;\n";
    ss << "        size_t saved_column = column_;\n";
    ss << "\n";
    
    // Генерация кода для правой части правила
    std::string on_failure_action = 
        "pos_ = saved_pos; line_ = saved_line; column_ = saved_column; --recursion_depth_; return nullptr;";
    
    ss << "        auto node = std::make_unique<" << makeIdentifier(rule.leftSide) << "Node>();\n";
    ss << visitNode(rule.rightSide.get(), on_failure_action);
    ss << "\n";
    ss << "        --recursion_depth_;\n";
    ss << "        return node;\n";
    ss << "    }\n";
    
    return ss.str();
}

// Обобщённый метод визитации узлов
std::string CppCodeGenerator::visitNode(const ASTNode* node, const std::string& on_failure_action) {
    if (const auto* term = dynamic_cast<const Terminal*>(node)) {
        return visitTerminal(term, on_failure_action);
    } else if (const auto* nonterm = dynamic_cast<const NonTerminal*>(node)) {
        return visitNonTerminal(nonterm, on_failure_action);
    } else if (const auto* range = dynamic_cast<const CharRange*>(node)) {
        return visitCharRange(range, on_failure_action);
    } else if (const auto* alt = dynamic_cast<const Alternative*>(node)) {
        return visitAlternative(alt, on_failure_action);
    } else if (const auto* seq = dynamic_cast<const Sequence*>(node)) {
        return visitSequence(seq, on_failure_action);
    } else if (const auto* group = dynamic_cast<const Group*>(node)) {
        return visitGroup(group, on_failure_action);
    } else if (const auto* opt = dynamic_cast<const Optional*>(node)) {
        return visitOptional(opt, on_failure_action);
    } else if (const auto* zero = dynamic_cast<const ZeroOrMore*>(node)) {
        return visitZeroOrMore(zero, on_failure_action);
    } else if (const auto* one = dynamic_cast<const OneOrMore*>(node)) {
        return visitOneOrMore(one, on_failure_action);
    } else if (const auto* action = dynamic_cast<const ContextAction*>(node)) {
        return visitContextAction(action, on_failure_action);
    }
    
    return "        // Unknown node type\n";
}

std::string CppCodeGenerator::visitTerminal(const Terminal* node, const std::string& on_failure_action) {
    std::ostringstream ss;
    ss << "        // Match terminal: \"" << escapeString(node->value) << "\"\n";
    ss << "        if (!matchString(\"" << escapeString(node->value) << "\")) {\n";
    ss << "            " << on_failure_action << "\n";
    ss << "        }\n";
    return ss.str();
}

std::string CppCodeGenerator::visitNonTerminal(const NonTerminal* node, const std::string& on_failure_action) {
    std::ostringstream ss;
    std::string child_var = "child_" + std::to_string(variable_counter_++);
    ss << "        // Parse non-terminal: " << node->name;
    
    if (node->hasParameters()) {
        ss << " with parameters [";
        for (size_t i = 0; i < node->parameterValues.size(); ++i) {
            if (i > 0) ss << ", ";
            ss << node->parameterValues[i];
        }
        ss << "]";
    }
    ss << "\n";
    
    // Генерируем вызов функции с параметрами или без
    ss << "        auto " << child_var << " = parse_" << makeIdentifier(node->name) << "(";
    
    if (node->hasParameters()) {
        ss << generateParameterPassing(node->parameterValues);
    }
    
    ss << ");\n";
    ss << "        if (!" << child_var << ") {\n";
    ss << "            " << on_failure_action << "\n";
    ss << "        }\n";
    ss << "        node->children.push_back(std::move(" << child_var << "));\n";
    return ss.str();
}

std::string CppCodeGenerator::visitCharRange(const CharRange* node, const std::string& on_failure_action) {
    std::ostringstream ss;
    ss << "        // Match character range: U+" << std::hex << std::uppercase 
       << node->start << " .. U+" << node->end << std::dec << std::nouppercase << "\n";
    ss << "        if (pos_ >= input_.size()) {\n";
    ss << "            " << on_failure_action << "\n";
    ss << "        }\n";
    ss << "        // Extract current codepoint\n";
    ss << "        size_t char_len = 1;\n";
    ss << "        uint32_t cp = static_cast<unsigned char>(input_[pos_]);\n";
    ss << "        if ((input_[pos_] & 0x80) != 0) {\n";
    ss << "            // UTF-8 multi-byte character\n";
    ss << "            unsigned char firstByte = static_cast<unsigned char>(input_[pos_]);\n";
    ss << "            if ((firstByte & 0xE0) == 0xC0) char_len = 2;\n";
    ss << "            else if ((firstByte & 0xF0) == 0xE0) char_len = 3;\n";
    ss << "            else if ((firstByte & 0xF8) == 0xF0) char_len = 4;\n";
    ss << "            if (pos_ + char_len > input_.size()) {\n";
    ss << "                " << on_failure_action << "\n";
    ss << "            }\n";
    ss << "            // Decode UTF-8 codepoint\n";
    ss << "            if (char_len == 2) {\n";
    ss << "                cp = ((firstByte & 0x1F) << 6) | (static_cast<unsigned char>(input_[pos_ + 1]) & 0x3F);\n";
    ss << "            } else if (char_len == 3) {\n";
    ss << "                cp = ((firstByte & 0x0F) << 12) | ((static_cast<unsigned char>(input_[pos_ + 1]) & 0x3F) << 6) | (static_cast<unsigned char>(input_[pos_ + 2]) & 0x3F);\n";
    ss << "            } else if (char_len == 4) {\n";
    ss << "                cp = ((firstByte & 0x07) << 18) | ((static_cast<unsigned char>(input_[pos_ + 1]) & 0x3F) << 12) | ((static_cast<unsigned char>(input_[pos_ + 2]) & 0x3F) << 6) | (static_cast<unsigned char>(input_[pos_ + 3]) & 0x3F);\n";
    ss << "            }\n";
    ss << "        }\n";
    ss << "        if (cp < " << node->start << "U || cp > " << node->end << "U) {\n";
    ss << "            " << on_failure_action << "\n";
    ss << "        }\n";
    ss << "        // Advance by character length\n";
    ss << "        for (size_t i = 0; i < char_len; ++i) {\n";
    ss << "            advance();\n";
    ss << "        }\n";
    return ss.str();
}


std::string CppCodeGenerator::visitAlternative(const Alternative* node, const std::string& on_failure_action) {
    std::ostringstream ss;
    std::string label_base = std::to_string(variable_counter_++);
    
    ss << "        // Try alternatives\n";
    ss << "        {\n";
    ss << "            bool alt_matched_" << label_base << " = false;\n";
    
    for (size_t i = 0; i < node->choices.size(); ++i) {
        ss << "            if (!alt_matched_" << label_base << ") {\n";
        ss << "                size_t alt_pos = pos_;\n";
        ss << "                size_t alt_line = line_;\n";
        ss << "                size_t alt_column = column_;\n";
        
        ss << "                do { // Alternative " << (i + 1) << "\n";
        
        std::string alt_label = "alt_failed_" + label_base + "_" + std::to_string(i);
        std::string on_alt_failure =
            "pos_ = alt_pos; line_ = alt_line; column_ = alt_column; goto " + alt_label + ";";
        
        ss << "                " << visitNode(node->choices[i].get(), on_alt_failure) << "\n";
        ss << "                alt_matched_" << label_base << " = true;\n";
        ss << "                } while(false);\n";
        ss << "            }\n";
        ss << "            " << "alt_failed_" << label_base << "_" << i << ":; // Label for this alternative\n";
    }
    
    ss << "            if (!alt_matched_" << label_base << ") {\n";
    ss << "                " << on_failure_action << "\n";
    ss << "            }\n";
    ss << "        }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::visitSequence(const Sequence* node, const std::string& on_failure_action) {
    std::ostringstream ss;
    ss << "        // Parse sequence\n";
    ss << "        do { // Sequence block\n";
    bool first = true;
    for (const auto& element : node->elements) {
        if (first) {
            ss << visitNode(element.get(), on_failure_action);
            first = false;
        } else {
            // Для последующих элементов выход из блока - это провал всей последовательности
            ss << visitNode(element.get(), "break;");
        }
    }
    ss << "        } while(false); // End of sequence block\n";
    return ss.str();
}

std::string CppCodeGenerator::visitGroup(const Group* node, const std::string& on_failure_action) {
    return visitNode(node->content.get(), on_failure_action);
}

std::string CppCodeGenerator::visitOptional(const Optional* node, [[maybe_unused]] const std::string& on_failure_action) {
    std::ostringstream ss;
    ss << "        // Optional\n";
    ss << "        do {\n";
    ss << "            size_t opt_pos = pos_;\n";
    ss << "            size_t opt_line = line_;\n";
    ss << "            size_t opt_column = column_;\n";
    ss << "            size_t opt_children_size = node->children.size();\n";
    
    std::string on_opt_failure = 
        "pos_ = opt_pos; line_ = opt_line; column_ = opt_column; "
        "while (node->children.size() > opt_children_size) { node->children.pop_back(); } "
        "break;"; // break from do-while

    ss << "            " << visitNode(node->content.get(), on_opt_failure) << "\n";
    ss << "        } while(false);\n";
    
    return ss.str();
}

std::string CppCodeGenerator::visitZeroOrMore(const ZeroOrMore* node, [[maybe_unused]] const std::string& on_failure_action) {
    std::ostringstream ss;
    ss << "        // Zero or more repetitions\n";
    ss << "        while (true) {\n";
    ss << "            size_t rep_pos = pos_;\n";
    ss << "            size_t rep_line = line_;\n";
    ss << "            size_t rep_column = column_;\n";
    ss << "            size_t rep_children_size = node->children.size();\n";
    
    std::string on_rep_failure = 
        "pos_ = rep_pos; line_ = rep_line; column_ = rep_column; "
        "while (node->children.size() > rep_children_size) { node->children.pop_back(); } "
        "break;";
        
    ss << visitNode(node->content.get(), on_rep_failure);
    
    ss << "        }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::visitOneOrMore(const OneOrMore* node, const std::string& on_failure_action) {
    std::ostringstream ss;
    ss << "        // One or more repetitions\n";
    ss << "        {\n";
    ss << "            int match_count = 0;\n";
    ss << "            while (true) {\n";
    ss << "                size_t rep_pos = pos_;\n";
    ss << "                size_t rep_line = line_;\n";
    ss << "                size_t rep_column = column_;\n";
    ss << "                size_t rep_children_size = node->children.size();\n";
    
    std::string on_rep_failure = 
        "pos_ = rep_pos; line_ = rep_line; column_ = rep_column; "
        "while (node->children.size() > rep_children_size) { node->children.pop_back(); } "
        "break;";
        
    ss << visitNode(node->content.get(), on_rep_failure);

    ss << "                match_count++;\n";
    ss << "            }\n";
    ss << "            if (match_count == 0) {\n";
    ss << "                " << on_failure_action << "\n";
    ss << "            }\n";
    ss << "        }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateHelperMethods() {
    std::ostringstream ss;
    
    ss << "    // Helper methods\n";
    ss << "    void skipWhitespace() {\n";
    ss << "        // This is a basic whitespace skipper. A real implementation would\n";
    ss << "        // use the WHITESPACE rule from the grammar if it exists.\n";
    ss << "        while (pos_ < input_.size() && std::isspace(input_[pos_])) {\n";
    ss << "            if (input_[pos_] == '\\n') {\n";
    ss << "                ++line_;\n";
    ss << "                column_ = 1;\n";
    ss << "            } else {\n";
    ss << "                ++column_;\n";
    ss << "            }\n";
    ss << "            ++pos_;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "\n";
    ss << "    void advance() {\n";
    ss << "        if (pos_ < input_.size()) {\n";
    ss << "            if (input_[pos_] == '\\n') {\n";
    ss << "                ++line_;\n";
    ss << "                column_ = 1;\n";
    ss << "            } else {\n";
    ss << "                ++column_;\n";
    ss << "            }\n";
    ss << "            ++pos_;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "\n";
    ss << "    bool matchString(const std::string& str) {\n";
    ss << "        skipWhitespace();\n";
    ss << "        if (pos_ + str.size() > input_.size()) {\n";
    ss << "            return false;\n";
    ss << "        }\n";
    ss << "        if (input_.substr(pos_, str.size()) == str) {\n";
    ss << "            for (size_t i = 0; i < str.size(); ++i) {\n";
    ss << "                advance();\n";
    ss << "            }\n";
    ss << "            return true;\n";
    ss << "        }\n";
    ss << "        return false;\n";
    ss << "    }\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateFooter() {
    return "// End of generated parser\n";
}

std::string CppCodeGenerator::getIndent(size_t level) const {
    return std::string(level * 4, ' ');
}

std::string CppCodeGenerator::generateComment(const std::string& comment) const {
    return "// " + comment + "\n";
}

std::string CppCodeGenerator::generateMainCpp(const Grammar& /* grammar */) {
    std::ostringstream ss;
    
    ss << "// Generated main.cpp for " << options_.parser_name << "\n";
    ss << "// This file provides a command-line interface for the parser\n\n";
    
    ss << "#include <iostream>\n";
    ss << "#include <fstream>\n";
    ss << "#include <sstream>\n";
    ss << "#include <string>\n";
    ss << "#include <cstring>\n\n";
    
    ss << "// Include the generated parser\n";
    ss << "#include \"" << camelToSnake(options_.parser_name) << ".cpp\"\n\n";
    
    if (!options_.namespace_name.empty()) {
        ss << "using namespace " << options_.namespace_name << ";\n\n";
    }
    
    ss << "struct CommandLineOptions {\n";
    ss << "    std::string input_file;\n";
    ss << "    bool show_ast = false;\n";
    ss << "    bool verbose = false;\n";
    ss << "    bool help = false;\n";
    ss << "};\n\n";
    
    ss << "void printHelp(const char* program_name) {\n";
    ss << "    std::cout << \"" << options_.parser_name << " - Generated parser\\n\\n\";\n";
    ss << "    std::cout << \"Usage: \" << program_name << \" [options] <input_file>\\n\\n\";\n";
    ss << "    std::cout << \"Options:\\n\";\n";
    ss << "    std::cout << \"  -a, --ast       Show parsed AST\\n\";\n";
    ss << "    std::cout << \"  -v, --verbose   Verbose output\\n\";\n";
    ss << "    std::cout << \"  -h, --help      Show this help\\n\";\n";
    ss << "}\n\n";
    
    ss << "CommandLineOptions parseArgs(int argc, char* argv[]) {\n";
    ss << "    CommandLineOptions opts;\n";
    ss << "    \n";
    ss << "    for (int i = 1; i < argc; ++i) {\n";
    ss << "        std::string arg = argv[i];\n";
    ss << "        if (arg == \"-h\" || arg == \"--help\") {\n";
    ss << "            opts.help = true;\n";
    ss << "        } else if (arg == \"-a\" || arg == \"--ast\") {\n";
    ss << "            opts.show_ast = true;\n";
    ss << "        } else if (arg == \"-v\" || arg == \"--verbose\") {\n";
    ss << "            opts.verbose = true;\n";
    ss << "        } else if (arg[0] != '-') {\n";
    ss << "            opts.input_file = arg;\n";
    ss << "        }\n";
    ss << "    }\n";
    ss << "    \n";
    ss << "    return opts;\n";
    ss << "}\n\n";
    
    ss << "std::string readFile(const std::string& filename) {\n";
    ss << "    std::ifstream file(filename);\n";
    ss << "    if (!file) {\n";
    ss << "        throw std::runtime_error(\"Cannot open file: \" + filename);\n";
    ss << "    }\n";
    ss << "    std::stringstream buffer;\n";
    ss << "    buffer << file.rdbuf();\n";
    ss << "    return buffer.str();\n";
    ss << "}\n\n";
    
    ss << "int main(int argc, char* argv[]) {\n";
    ss << "    try {\n";
    ss << "        auto opts = parseArgs(argc, argv);\n";
    ss << "        \n";
    ss << "        if (opts.help || opts.input_file.empty()) {\n";
    ss << "            printHelp(argv[0]);\n";
    ss << "            return opts.help ? 0 : 1;\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        if (opts.verbose) {\n";
    ss << "            std::cout << \"Parsing file: \" << opts.input_file << \"\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        std::string input = readFile(opts.input_file);\n";
    ss << "        \n";
    ss << "        if (opts.verbose) {\n";
    ss << "            std::cout << \"Input size: \" << input.size() << \" bytes\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        " << options_.parser_name << " parser(input);\n";
    ss << "        auto result = parser.parse();\n";
    ss << "        \n";
    ss << "        if (!result) {\n";
    ss << "            std::cerr << \"Parse error: \" << parser.getError() << \"\\n\";\n";
    ss << "            return 1;\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        if (opts.verbose) {\n";
    ss << "            std::cout << \"✓ Parse successful\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        if (opts.show_ast) {\n";
    ss << "            std::cout << \"AST:\\n\" << result->toString() << \"\\n\";\n";
    ss << "        }\n";
    ss << "        \n";
    ss << "        return 0;\n";
    ss << "        \n";
    ss << "    } catch (const std::exception& e) {\n";
    ss << "        std::cerr << \"Error: \" << e.what() << \"\\n\";\n";
    ss << "        return 1;\n";
    ss << "    }\n";
    ss << "}\n";
    
    return ss.str();
}

// Extended BNF методы

std::string CppCodeGenerator::visitContextAction(const ContextAction* node, const std::string& on_failure_action) {
    std::ostringstream ss;
    ss << "        // Context action: " << node->toString() << "\n";
    
    switch (node->actionType) {
        case ContextAction::ActionType::STORE:
            if (node->arguments.size() >= 2) {
                ss << "        context_storage_[\"" << node->arguments[0] << "\"] = " 
                   << node->arguments[1] << ";\n";
            }
            break;
        case ContextAction::ActionType::LOOKUP:
            if (node->arguments.size() >= 1) {
                ss << "        if (context_storage_.find(\"" << node->arguments[0] 
                   << "\") == context_storage_.end()) {\n";
                ss << "            " << on_failure_action << "; // Context lookup failed\n";
                ss << "        }\n";
            }
            break;
        case ContextAction::ActionType::CHECK:
            if (node->arguments.size() >= 1) {
                ss << "        if (!(" << node->arguments[0] << ")) {\n";
                ss << "            " << on_failure_action << "; // Context check failed\n";
                ss << "        }\n";
            }
            break;
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateParameterizedFunction(const ProductionRule& rule) {
    std::ostringstream ss;
    std::string func_name = "parse_" + makeIdentifier(rule.leftSide);
    
    // Генерируем сигнатуру функции с параметрами
    ss << "    std::shared_ptr<ASTNode> " << func_name << "(";
    
    if (!rule.parameters.empty()) {
        ss << generateParameterDeclarations(rule.parameters);
    }
    
    ss << ") {\n";
    ss << "        if (++recursion_depth_ > max_recursion_depth_) {\n";
    ss << "            --recursion_depth_;\n";
    ss << "            return nullptr; // Max recursion depth exceeded\n";
    ss << "        }\n\n";
    
    ss << "        size_t saved_pos = pos_;\n";
    ss << "        size_t saved_line = line_;\n";
    ss << "        size_t saved_column = column_;\n";
    ss << "        auto node = std::make_shared<ASTNode>(\"" << rule.leftSide << "\");\n\n";
    
    // Генерируем тело функции
    std::string on_failure_action = 
        "pos_ = saved_pos; line_ = saved_line; column_ = saved_column; --recursion_depth_; return nullptr;";
    ss << visitNode(rule.rightSide.get(), on_failure_action);
    
    ss << "\n        --recursion_depth_;\n";
    ss << "        return node;\n";
    ss << "    }\n\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateParameterTypes(const std::vector<RuleParameter>& params) {
    std::ostringstream ss;
    
    for (const auto& param : params) {
        switch (param.type) {
            case ParameterType::ENUM:
                ss << generateEnumDeclaration(param) << "\n";
                break;
            case ParameterType::INTEGER:
            case ParameterType::STRING:
            case ParameterType::BOOLEAN:
                // Встроенные типы не требуют объявления
                break;
        }
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateParameterDeclarations(const std::vector<RuleParameter>& params) {
    std::ostringstream ss;
    
    for (size_t i = 0; i < params.size(); ++i) {
        if (i > 0) ss << ", ";
        
        switch (params[i].type) {
            case ParameterType::ENUM:
                ss << params[i].name << "Enum " << params[i].name;
                break;
            case ParameterType::INTEGER:
                ss << "int " << params[i].name;
                break;
            case ParameterType::STRING:
                ss << "const std::string& " << params[i].name;
                break;
            case ParameterType::BOOLEAN:
                ss << "bool " << params[i].name;
                break;
        }
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateParameterPassing(const std::vector<std::string>& paramValues) {
    std::ostringstream ss;
    
    for (size_t i = 0; i < paramValues.size(); ++i) {
        if (i > 0) ss << ", ";
        ss << paramValues[i];
    }
    
    return ss.str();
}

std::string CppCodeGenerator::generateEnumDeclaration(const RuleParameter& param) {
    std::ostringstream ss;
    
    ss << "enum class " << param.name << "Enum {\n";
    for (size_t i = 0; i < param.enumValues.size(); ++i) {
        if (i > 0) ss << ",\n";
        ss << "    " << param.enumValues[i];
    }
    ss << "\n};\n";
    
    return ss.str();
}

std::string CppCodeGenerator::generateContextStorage() {
    return "    std::unordered_map<std::string, std::string> context_storage_;\n";
}

std::string CppCodeGenerator::generateContextActions(const ContextAction* action) {
    return visitContextAction(action, "return nullptr;");
}

bool CppCodeGenerator::isExtendedBNF(const Grammar& grammar) const {
    return grammar.isContextSensitive();
}

bool CppCodeGenerator::hasParameterizedRules(const Grammar& grammar) const {
    for (const auto& rule : grammar.rules) {
        if (rule->hasParameters()) {
            return true;
        }
    }
    return false;
}

bool CppCodeGenerator::hasContextActions(const Grammar& grammar) const {
    // Проверяем наличие контекстных действий в правилах
    for (const auto& rule : grammar.rules) {
        if (hasContextActionsInNode(rule->rightSide.get())) {
            return true;
        }
    }
    return false;
}

// Вспомогательный метод для поиска контекстных действий в узлах
bool CppCodeGenerator::hasContextActionsInNode(const ASTNode* node) const {
    if (dynamic_cast<const ContextAction*>(node)) {
        return true;
    }
    
    if (const auto* seq = dynamic_cast<const Sequence*>(node)) {
        for (const auto& elem : seq->elements) {
            if (hasContextActionsInNode(elem.get())) return true;
        }
    }
    
    if (const auto* alt = dynamic_cast<const Alternative*>(node)) {
        for (const auto& choice : alt->choices) {
            if (hasContextActionsInNode(choice.get())) return true;
        }
    }
    
    if (const auto* grp = dynamic_cast<const Group*>(node)) {
        return hasContextActionsInNode(grp->content.get());
    }
    
    if (const auto* opt = dynamic_cast<const Optional*>(node)) {
        return hasContextActionsInNode(opt->content.get());
    }
    
    if (const auto* zom = dynamic_cast<const ZeroOrMore*>(node)) {
        return hasContextActionsInNode(zom->content.get());
    }
    
    if (const auto* oom = dynamic_cast<const OneOrMore*>(node)) {
        return hasContextActionsInNode(oom->content.get());
    }
    
    return false;
}

} // namespace bnf_parser_generator


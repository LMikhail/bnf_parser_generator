# GitLab CI/CD pipeline for BNF Parser

variables:
  BUILD_TYPE: "debug"
  CXX_STANDARD: "17"
  NINJA_JOBS: "4"

stages:
  - lint
  - build
  - test
  - release

# Cache to speed up builds
cache:
  paths:
    - out/
    - .gn/

# Base image with required dependencies
.base_image: &base_image
  image: ubuntu:22.04
  before_script:
    - apt-get update
    - apt-get install -y build-essential ninja-build git curl
    - |
      # Install GN
      curl -L https://chrome-infra-packages.appspot.com/dl/gn/gn/linux-amd64/+/latest -o gn.zip
      unzip gn.zip
      mv gn /usr/local/bin/
      gn --version

# Lint
lint:
  <<: *base_image
  stage: lint
  script:
    - echo "Code quality check..."
    - |
      # List a few source files (placeholder for real lint)
      find src include -name "*.cpp" -o -name "*.hpp" | head -10
    - |
      # Commit message format check (push only)
      if [ "$CI_PIPELINE_SOURCE" = "push" ]; then
        git log --format="%s" -1 | grep -E "^(feat|fix|docs|style|refactor|test|build|chore)(\(.+\))?: .+" || {
          echo "Invalid commit format"
          exit 1
        }
        echo "Commit format OK"
      fi
    - echo "Lint completed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Debug build
build:debug:
  <<: *base_image
  stage: build
  script:
    - echo "Building Debug..."
    - |
      # Create args.gn for debug build
      mkdir -p out/debug
      cat > out/debug/args.gn << EOF
      is_debug = true
      bnf_parser_enable_unicode = true
      bnf_parser_enable_tests = true
      bnf_parser_enable_examples = true
      EOF
    - gn gen out/debug
    - ninja -C out/debug all -j$NINJA_JOBS
    - echo "Debug build completed"
  artifacts:
    paths:
      - out/debug/
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Release build
build:release:
  <<: *base_image
  stage: build
  script:
    - echo "Building Release..."
    - |
      # Создаем args.gn для release сборки
      mkdir -p out/release
      cat > out/release/args.gn << EOF
      is_debug = false
      bnf_parser_enable_unicode = true
      bnf_parser_enable_tests = true
      bnf_parser_enable_examples = true
      EOF
    - gn gen out/release
    - ninja -C out/release all -j$NINJA_JOBS
    - echo "Release build completed"
  artifacts:
    paths:
      - out/release/
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "tag"

# Tests (debug)
test:debug:
  <<: *base_image
  stage: test
  dependencies:
    - build:debug
  script:
    - echo "Running tests..."
    - |
      # Unit tests
      if [ -f "out/debug/basic_test" ]; then
        echo "Running basic_test..."
        out/debug/basic_test
      fi
    - |
      # Example binaries smoke-check
      if [ -f "out/debug/simple_demo" ]; then
        echo "Running simple_demo..."
        out/debug/simple_demo || true
      fi
    - |
      # Debug helpers
      for debug_prog in out/debug/debug_*; do
        if [ -f "$debug_prog" ] && [ -x "$debug_prog" ]; then
          echo "Running $(basename $debug_prog)..."
          $debug_prog || true
        fi
      done
    - echo "Tests completed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# DCO check
dco:check:
  <<: *base_image
  stage: test
  script:
    - echo "DCO check..."
    - |
      # Ensure commits are signed
      git log --format='%H %s' -1 | grep -q 'Signed-off-by:' || {
        echo "Commit is not signed"
        exit 1
      }
      echo "DCO check passed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"

# Release artifacts
release:
  <<: *base_image
  stage: release
  dependencies:
    - build:release
  script:
    - echo "Creating release artifacts..."
    - |
      # Collect artifacts
      mkdir -p artifacts
      cp -r out/release/* artifacts/ 2>/dev/null || true
      cp -r docs/ artifacts/ 2>/dev/null || true
      cp README.md artifacts/ 2>/dev/null || true
    - |
      # Archive
      VERSION=${CI_COMMIT_TAG:-$(git describe --tags --abbrev=0 2>/dev/null || echo "dev")}
      tar -czf bnf-parser-${VERSION}.tar.gz artifacts/
      ls -la *.tar.gz
    - echo "Release artifacts created"
  artifacts:
    paths:
      - "*.tar.gz"
    expire_in: never
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"

# Automatic release check
auto:release:
  <<: *base_image
  stage: release
  script:
    - echo "Automatic release check..."
    - |
      # Decide whether a release is needed
      LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
      COMMITS_SINCE_TAG=$(git log --oneline $LAST_TAG..HEAD 2>/dev/null || git log --oneline)
      
      if echo "$COMMITS_SINCE_TAG" | grep -q "feat:\|fix:\|BREAKING CHANGE:"; then
        echo "Release-worthy commits found"
        # Add automated release logic here (e.g., tag and release creation)
      else
        echo "No release needed"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"

# Notifications
notify:success:
  stage: release
  script:
    - echo "Pipeline finished successfully"
    - echo "Time: $(date)"
    - echo "Commit: $CI_COMMIT_SHA"
    - echo "Branch: $CI_COMMIT_REF_NAME"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
  when: on_success

notify:failure:
  stage: release
  script:
    - echo "Pipeline failed"
    - echo "Time: $(date)"
    - echo "Commit: $CI_COMMIT_SHA"
    - echo "Branch: $CI_COMMIT_REF_NAME"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
  when: on_failure
